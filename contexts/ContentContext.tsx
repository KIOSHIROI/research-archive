
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { CONTENT, THEMES, SPECULATIVE_CONTENT, AUTHOR } from '../services/data';
import { ContentItem, ResearchTheme, SpeculativeCollection, GlobalContentIndex, Author } from '../types';

interface ContentContextType {
  author: Author;
  content: ContentItem[];
  themes: ResearchTheme[];
  speculative: SpeculativeCollection;
  isLoading: boolean;
  refresh: () => Promise<void>;
  // Admin helpers to allow optimistic updates before commit
  updateGlobalState: (newState: Partial<GlobalContentIndex>) => void;
}

const ContentContext = createContext<ContentContextType | undefined>(undefined);

export const ContentProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [author, setAuthor] = useState<Author>(AUTHOR);
  const [content, setContent] = useState<ContentItem[]>(CONTENT);
  const [themes, setThemes] = useState<ResearchTheme[]>(THEMES);
  const [speculative, setSpeculative] = useState<SpeculativeCollection>(SPECULATIVE_CONTENT);
  const [isLoading, setIsLoading] = useState(true);

  const fetchContent = async () => {
    setIsLoading(true);
    try {
      // Attempt to fetch dynamic index generated by Admin/CI
      const response = await fetch('/content.json?t=' + Date.now());
      if (response.ok) {
        const data: GlobalContentIndex = await response.json();
        
        // Update state if data exists, otherwise fall back to static initial state
        if (data.author) setAuthor(data.author);
        if (data.content && Array.isArray(data.content)) setContent(data.content);
        if (data.themes && Array.isArray(data.themes)) setThemes(data.themes);
        if (data.speculative) setSpeculative(data.speculative);
      }
    } catch (e) {
      console.warn("Using static content (Network error or no index found).", e);
    } finally {
      setIsLoading(false);
    }
  };

  const updateGlobalState = (newState: Partial<GlobalContentIndex>) => {
      if (newState.author) setAuthor(newState.author);
      if (newState.content) setContent(newState.content);
      if (newState.themes) setThemes(newState.themes);
      if (newState.speculative) setSpeculative(newState.speculative);
  };

  useEffect(() => {
    fetchContent();
  }, []);

  return (
    <ContentContext.Provider value={{ author, content, themes, speculative, isLoading, refresh: fetchContent, updateGlobalState }}>
      {children}
    </ContentContext.Provider>
  );
};

export const useContent = () => {
  const context = useContext(ContentContext);
  if (!context) {
    throw new Error('useContent must be used within a ContentProvider');
  }
  return context;
};

export const useAuthor = () => {
    const { author } = useContent();
    return author;
}

// Helper hooks for specific data slices
export const useThemes = () => {
    const { themes } = useContent();
    return themes.sort((a, b) => a.order - b.order);
}

// Filter out Drafts for public consumption
export const useAllContent = () => {
    const { content } = useContent();
    return content
      .filter(c => c.isDraft !== true)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

export const useSpeculative = () => {
    const { speculative } = useContent();
    return speculative;
}

export const useContentBySlug = (slug: string) => {
    const { content } = useContent();
    return content.find(c => c.slug === slug);
}

export const useContentByTheme = (themeId: string) => {
    const { content } = useContent();
    return content
      .filter(c => c.themeId === themeId && c.isDraft !== true)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}
